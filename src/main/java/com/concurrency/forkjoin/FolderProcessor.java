package com.concurrency.forkjoin;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.TimeUnit;

/**
 * This is a demo class for ForkJoinPool taken from this tutorial
 * http://howtodoinjava.com/2014/05/27/forkjoin-framework-tutorial-forkjoinpool-example/
 * <p/>
 * I slightly modified it.
 * <p/>
 * By paoloibarra on 20/10/14.
 */
public class FolderProcessor extends RecursiveTask<List<String>> {

    private final String path;
    private final String extension;

    @Override
    protected List<String> compute() {
        //List to store the names of the files stored in the folder.
        List<String> list = new ArrayList<String>();
        //FolderProcessor tasks to store the subtasks that are going to process the subfolders stored in the folder
        List<FolderProcessor> tasks = new ArrayList<FolderProcessor>();
        //Get the content of the folder.
        File file = new File(path);
        File allFile[] = file.listFiles();
        //For each element in the folder, if there is a subfolder, create a new FolderProcessor object 
        //and execute it asynchronously using the fork() method.
        if (allFile != null) {
            for (File content : allFile) {
                if (content.isDirectory()) {
                    FolderProcessor task = new FolderProcessor(content.getAbsolutePath(), extension);
                    task.fork();
                    tasks.add(task);
                } else if (checkFile(content.getName())) {
                    list.add(content.getAbsolutePath());
                }

            }
        }
        //If the list of the FolderProcessor subtasks has more than 50 elements, 
        //write a message to the console to indicate this circumstance.
        if (tasks.size() > 50) {
            System.out.printf("%s: %d tasks ran.\n", file.getAbsolutePath(), tasks.size());
        }
        //add to the list of files the results returned by the subtasks launched by this task.
        addResultsFromTasks(list, tasks);
        //Return the list of strings
        return list;
    }

    public FolderProcessor(String path, String extension) {
        this.path = path;
        this.extension = extension;
    }

    public static void main(String[] args) {
        //Create ForkJoinPool using the default constructor.
        ForkJoinPool pool = new ForkJoinPool();
        //Create three FolderProcessor tasks. Initialize each one with a different folder path.
        FolderProcessor logFiles = new FolderProcessor(args[0], "log");
        FolderProcessor markdownFiles = new FolderProcessor(args[0], "md");
        FolderProcessor rubyFiles = new FolderProcessor(args[0], "rb");
        //Execute the three tasks in the pool using the execute() method.
        pool.execute(logFiles);
        pool.execute(markdownFiles);
        pool.execute(rubyFiles);
        //Write to the console information about the status of the pool every second
        //until the three tasks have finished their execution.
        do {
            System.out.printf("******************************************\n");
            System.out.printf("Main: Parallelism: %d\n", pool.getParallelism());
            System.out.printf("Main: Active Threads: %d\n", pool.getActiveThreadCount());
            System.out.printf("Main: Task Count: %d\n", pool.getQueuedTaskCount());
            System.out.printf("Main: Steal Count: %d\n", pool.getStealCount());
            System.out.printf("******************************************\n");
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        } while ((!logFiles.isDone()) || (!markdownFiles.isDone()) || (!rubyFiles.isDone()));
        //Shut down ForkJoinPool using the shutdown() method.
        pool.shutdown();
        //Write the number of results generated by each task to the console.
        List<String> results;
        results = logFiles.join();
        System.out.printf("Log: %d files found.\n", results.size());
        results = markdownFiles.join();
        System.out.printf("Markdown: %d files found.\n", results.size());
        results = rubyFiles.join();
        System.out.printf("Ruby: %d files found.\n", results.size());
    }

    //For each task stored in the list of tasks, call the join() method that will wait for its finalization and then will return the result of the task.
    //Add that result to the list of strings using the addAll() method.
    private void addResultsFromTasks(List<String> list, List<FolderProcessor> tasks) {
        for (FolderProcessor item : tasks) {
            list.addAll(item.join());
        }
    }

    //This method compares if the name of a file passed as a parameter ends with the extension you are looking for.
    private boolean checkFile(String name) {
        return name.endsWith(extension);
    }

}
